#include <iostream>
#include <clocale> 

// ==================== ЗАДАНИЕ 1 ====================
void task1() {
    setlocale(LC_ALL, "Russian");
    std::cout << "=== ЗАДАНИЕ 1 ===" << std::endl;

    // 1. Объявляем переменную типа int со значением 100
    int number = 100;

    // 2. Создаем указатель p на эту переменную
    // & - оператор взятия адреса переменной
    int* p = &number;

    // 3. Создаем указатель q = p - 1
    // Арифметика указателей: p - 1 смещает указатель на 1 элемент назад
    // В нашем случае элемент - это int, поэтому смещение на sizeof(int) байт
    int* q = p - 1;

    // 4. Выводим адреса и разность
    std::cout << "1. Значение переменной number: " << number << std::endl;
    std::cout << "2. Адрес переменной number (&number): " << &number << std::endl;
    std::cout << "3. Значение указателя p (адрес, на который он указывает): " << p << std::endl;
    std::cout << "4. Значение, на которое указывает p (*p): " << *p << std::endl;
    std::cout << "5. Значение указателя q (адрес, на который он указывает): " << q << std::endl;

    // Разность указателей показывает количество элементов между ними
    std::cout << "6. Разность p - q (в элементах): " << (p - q) << std::endl;

    // Чтобы получить разность в байтах, преобразуем в char*
    // char занимает 1 байт, поэтому разница будет в байтах
    std::cout << "7. Разность в байтах: "
        << reinterpret_cast<char*>(p) - reinterpret_cast<char*>(q)
        << " байт" << std::endl;

    std::cout << "8. Размер int на этой системе: " << sizeof(int) << " байт" << std::endl;

    // ОБЪЯСНЕНИЕ ОПАСНОСТИ РАЗЫМЕНОВАНИЯ q:
    std::cout << "\nПОЧЕМУ РАЗЫМЕНОВАНИЕ q ОПАСНО:" << std::endl;
    std::cout << "1. Указатель q указывает на область памяти ДО нашей переменной number" << std::endl;
    std::cout << "2. Эта область может содержать:" << std::endl;
    std::cout << "   - Мусорные данные (неинициализированная память)" << std::endl;
    std::cout << "   - Данные других переменных" << std::endl;
    std::cout << "   - Системные данные (например, адреса возврата функций)" << std::endl;
    std::cout << "   - Защищённую память (что вызовет ошибку сегментации)" << std::endl;
    std::cout << "3. Чтение из этой области дает неопределенный результат" << std::endl;
    std::cout << "4. Запись в эту область может:" << std::endl;
    std::cout << "   - Повредить другие переменные" << std::endl;
    std::cout << "   - Вызвать сбой программы" << std::endl;
    std::cout << "   - Создать уязвимости безопасности" << std::endl;

    // Демонстрация (НЕ делайте этого в реальных программах!)
    // Закомментировано, так как это небезопасно
    /*
    std::cout << "\nПопытка разыменовать q (ОПАСНО!):" << std::endl;
    int dangerous_value = *q; // НЕОПРЕДЕЛЕННОЕ ПОВЕДЕНИЕ!
    std::cout << "Результат (может быть любым): " << dangerous_value << std::endl;
    */
}

// ==================== ЗАДАНИЕ 2 ====================
void task2() {
    setlocale(LC_ALL, "Russian");
    std::cout << "\n=== ЗАДАНИЕ 2 ===" << std::endl;

    const int SIZE = 12; // Размер массива
    std::cout << "1. Выделяем динамическую память для массива из " << SIZE << " элементов типа short" << std::endl;

    // 1. Динамическое выделение памяти для массива
    // new short[SIZE] выделяет память для SIZE элементов типа short
    short* array = new short[SIZE];

    // 2. Заполнение массива четными числами от 2 до 24
    std::cout << "2. Заполняем массив четными числами от 2 до 24:" << std::endl;
    std::cout << "   - Начинаем с последнего элемента" << std::endl;
    std::cout << "   - Двигаемся к первому" << std::endl;

    // Указатель на последний элемент массива
    // array + SIZE - 1 = адрес последнего элемента
    // array[0] = первый элемент
    // array[SIZE-1] = последний элемент
    short* ptr = array + SIZE - 1; // Указатель на последний элемент

    // Заполняем от последнего к первому
    for (int i = 0; i < SIZE; i++) {
        // Четные числа от 24 до 2
        // 24 - i * 2 дает: 24, 22, 20, ..., 2
        *ptr = 24 - i * 2;

        // Проверка для отладки
        std::cout << "   Элемент [" << (ptr - array) << "] = " << *ptr << std::endl;

        // Перемещаем указатель на один элемент назад
        ptr--;
    }

    // 3. Вывод массива с помощью указательной арифметики
    std::cout << "\n3. Выводим массив от первого к последнему элементу:" << std::endl;
    std::cout << "   Массив: ";

    // Сбрасываем указатель на начало массива
    ptr = array; // Теперь ptr указывает на первый элемент

    for (int i = 0; i < SIZE; i++) {
        // Выводим значение, на которое указывает ptr
        std::cout << *ptr;

        // Если не последний элемент, добавляем запятую
        if (i < SIZE - 1) {
            std::cout << ", ";
        }

        // Перемещаем указатель на следующий элемент
        ptr++; // Эквивалентно ptr = ptr + 1
    }
    std::cout << std::endl;

    // 4. Освобождение памяти
    std::cout << "\n4. Освобождаем выделенную память" << std::endl;
    delete[] array; // Очень важно использовать delete[] для массивов

    // Обнуляем указатель для безопасности
    array = nullptr;
    ptr = nullptr;

    std::cout << "Память успешно освобождена!" << std::endl;
}

// ==================== ГЛАВНАЯ ФУНКЦИЯ ====================
int main() {
    setlocale(LC_ALL, "Russian");
    std::cout << "ПРОГРАММА ДЛЯ ИЗУЧЕНИЯ УКАЗАТЕЛЕЙ" << std::endl;
    std::cout << "================================" << std::endl;

    int choice;
    std::cout << "\nВыберите задание:" << std::endl;
    std::cout << "1. Работа с указателями (адресная арифметика)" << std::endl;
    std::cout << "2. Работа с динамическими массивами" << std::endl;
    std::cout << "3. Выполнить оба задания" << std::endl;
    std::cout << "Ваш выбор (1-3): ";

    std::cin >> choice;

    switch (choice) {
    case 1:
        task1();
        break;
    case 2:
        task2();
        break;
    case 3:
        task1();
        task2();
        break;
    default:
        std::cout << "Неверный выбор!" << std::endl;
        return 1;
    }

    return 0;
}